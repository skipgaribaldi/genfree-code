/////////////////////////////////////////////////////////////////
//
// Magma code to verify that some number of conjugates of a root element
// generate [so_2n, so_2n] in so_2n in characteristic 2
//     in support of a paper by Skip Garibaldi & Robert M. Guralnick
//
// ran using Magma V2.14-13
//
// version of 8/21/17
//
/////////////////////////////////////////////////////////////////

load "genfree-codebase-part1.magma";

print "Checking how many conjugates of certain elements of spin_n are needed to generate the Lie algebra";
print "Base field is finite of characteristic 2";
print "This is in support of Garibaldi-Guralnick I, Example 10.2";

// generate quasi-random product of elements of g
// gens = sequence of elements of g
function rand_from_gens(gens);
	assert Nrows(gens[1]) eq Ncols(gens[1]);
	d := Nrows(gens[1]);
	F := BaseRing(gens[1]);

	id := IdentityMatrix(F, d);
	rval := id;

	for i in [1..10] do 
		for gen in gens do
			grp_elt := id + Random(F) * gen;   // random group element
			rval := rval*grp_elt; // throw it in to the product
		end for;
	end for;
	return rval;
end function;

// x is a matrix
// gens is a bunch of root elements from a Lie algebra, matrices of the same shape as x
// returns a random comjugate of x
function randomConjugate(x, gens);
	Y := rand_from_gens(gens);
	return Y*Matrix(x)*(Y^-1);
end function;

// approximate the sub-Lie-algebra generated by various matrices 
// gl = matrix Lie algebra in which to work
// gens = list of generators
// returns a subalgebra that is putatively the subalgebra generated by conjugates of gens
//     ... the returned subalgebra is only guaranteed to be contained in the subalgebra generated by the conjugates

function SubAlgebraGenerated(gl, gens);
	L := sub<gl | gens>;

	repeat
		dim := Dimension(L); // how big is L?
		for i in [1..10] do
			newelt := Random(L)*Random(L);   // bracket two random elements of L
			L := sub<gl | Append(Basis(L), newelt)>; // add newelt to L
		end for;
	until dim eq Dimension(L); // give up when the dimension didn't get any bigger

	return L;
end function;

// input : x = matrix
// output : list of sizes of Jordan blocks of x
function JordanBlockSizes(x);
	_, _, lst := JordanForm(x);
	return [y[2] : y in lst];
end function;

// we list the dimension of the subalgebra of Spin_2n generated by e generic conjugates of 
// a nilpotent of rank 2r...  this is over a field of char 2
// makes 10 choices of random conjugates, returns a list of the dimensions of the generated subalgebra
function DSubalgGen(n, r, e);
	F := GF(2^9); // we definitely characteristic 2

	gl := MatrixLieAlgebra(F, 2*n); // the natural representation

	// construct g = spin
	R := IrreducibleRootDatum("D", n : Isogeny := "SC");
	g := LieAlgebra(R, F); 
	basis := Basis(g);

	// the natural representation
	wt := [ 0 : i in [1..n]];
	wt[1] := 1;
	nat := HighestWeightRepresentation(g, wt); // the Weyl module 

	// construct the subalgebra [so, so] which we abuse notation and denote by so
	sogens := [ gl!nat(b) : b in basis ];
	so := SubAlgebraGenerated(gl, sogens);
	assert Dimension(so) eq 2*n^2-n-1; // verify that so = the image of spin_2n in so_2n

	UplusInd := [1..(n^2-n)]; // the first part of the basis are in the Borel defining the pinning
	torInd := [(n^2-n+1)..n^2]; // the middle 4 are in the torus
	UminusInd := [(n^2+1)..(2*n^2-n)]; // the bottom part are in the opposite Borel

	rootelts := [ Matrix(nat(basis[i])) : i in UplusInd cat UminusInd ];

	for elt in rootelts do
		assert IsNilpotent(elt);
	end for;

	// now r comes into play ; we pick an element x with rank 2r
	if r eq 1 then // rank 2
		x := sogens[1];
		assert JordanBlockSizes(x) eq [1 : i in [1..(2*n-4)]] cat [2, 2];
	else 
		assert r eq 2; // we better be looking at rank 4
		x := sogens[n^2-n] + sogens[n^2-n-3];
		assert JordanBlockSizes(x) eq [1 : i in [1..(2*n-8)]] cat [2 : j in [1..4]];
	end if;
	assert Rank(x) eq 2*r;
	assert IsNilpotent(x);

	dims := [];
	for step in [1..10] do
		gens := [ x ];
		for i in [2..e] do  // e is the number of random conjugates of x
			Append(~gens, gl!randomConjugate(x, rootelts));
		end for;

		L := SubAlgebraGenerated(gl, gens);
		Append(~dims, Dimension(L));
	end for;
	return dims;
end function;

// x = nilpotent in Spin_2n of rank 2*r
// r = 1 (root element) or 2 (sum of two orthogonal roots) 
// return boolean: does the claimed number of generic conjugates generate spin_8?
function DRootGen(n, r);
    e := Max([4, Ceiling(n/r)]);
	printf "Checking spin_%o", 2*n;
	printf " with an element of rank %o ; do %o generic conjugates generate?\n", 2*r, e;
	lst := DSubalgGen(n, r, e);
	// print lst;

	return Max(lst) eq 2*n^2 - n - 1;
end function;

DRootGen(4, 1);
DRootGen(5, 1);
DRootGen(7, 2);
DRootGen(8, 2);
