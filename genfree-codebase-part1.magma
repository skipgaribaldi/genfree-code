///////////////////////////////////////////////////////////////
//
// Magma code for computing (actually, giving upper bound for) the dimension of
// the generic stabilizer for a Lie algebra acting on an irreducible representation
//     in support of a paper by Skip Garibaldi & Robert M. Guralnick
//
// version of 4/19/17
//
/////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////
//
// Given a vector space V on which rho(g) acts on the right, find the submodule generated by 
// a vector v
//
/////////////////////////////////////////////////////////////////
function subGen(V, v, g, rho);
	Vp := sub<V | v>;
	odim := 0;
	while Dimension(Vp) ne odim do
	    odim := Dimension(Vp);
		Vp := sub<V | [vp * rho(x) : x in Basis(g), vp in Basis(Vp)] >;
	end while;

	return Vp;
end function;

/////////////////////////////////////////////////////////////////
//
// Given a vector space V on which rho(g) acts on the right, find
// the subalgebra of g stabilizing a vector v in V
// 
// 		StabilizerSubspace returns a subspace representation
//      StabilizerSubalgebra returns as a subalgebra of g
//
/////////////////////////////////////////////////////////////////
function StabilizerSubspace(v, g, rho);
	mats := VerticalJoin([v*rho(x) : x in Basis(g)]);
	return Kernel(mats);
end function;

function SubspaceToSubalgebra(g, subspace);
   	gens := [];
    for vec in Basis(subspace) do
    	Append(~gens, &+ [ vec[i]*Basis(g)[i] : i in [1..Dimension(g)]]);
    end for;

    return sub<g | gens>;
end function;

function StabilizerSubalgebra(v, g, rho);
	return SubspaceToSubalgebra(g, StabilizerSubspace(v, g, rho));
end function;


/////////////////////////////////////////////////////////////////
//
// Given a vector space V on which rho(g) acts on the right, find
// the subalgebra of g stabilizing a vector v in V
// 
// 		StabilizerSubspace returns a subspace representation
//      StabilizerSubalgebra returns as a subalgebra of g
//
/////////////////////////////////////////////////////////////////
function KerOfMap(g, rho);
    rho_mat := VerticalJoin([Vector(rho(bas)) : bas in Basis(g)]);
    return SubspaceToSubalgebra(Kernel(rho_mat));
end function;

/////////////////////////////////////////////////////////////////
//
// Given a sequence, return the index of a minimal element
//
/////////////////////////////////////////////////////////////////
function Argmin(seq);
	min := Min(seq);
	return Index(seq, min);
end function;

/////////////////////////////////////////////////////////////////
//
// Given a matrix and a subspace stabilized by that matrix,
// return the matrix representing a restriction of the matrix to the
// subspace
//
/////////////////////////////////////////////////////////////////
function RestrictionOfMatrix(mat, subspace);
	return Matrix([Coordinates(subspace, v*mat) : v in Basis(subspace)]);
end function;

function KerOfRestrictionOfMap(g, rho, subspace);
	rho_mat := VerticalJoin([Vector(RestrictionOfMatrix(rho(bas), subspace)) : bas in Basis(g)]);
	return SubspaceToSubalgebra(g, Kernel(rho_mat));
end function;

/////////////////////////////////////////////////////////////////
//
// Given a Lie algebra g, weyl : g --> matrix ring
// and edim = expected dimension of the irreducible submodule,
// this function creates the irreducible submodule, 
// verifies that it has the expected dimension
// generates 10 random vectors in the irreducible representation
// and returns the minimum of the dimensions of the stabilizers of those vectors.
// This is an upper bound on the dimension of the generic stabilizer.
// Empirically, 10 samples are enough to find the actual dimension.
//
/////////////////////////////////////////////////////////////////
function genStab(g, weyl, irred);
	dims := [];
	stabs := [];
	for i in [1..10] do  // going to pick 10 random vectors in V, look for smallest stabilizer
		rand := Random(irred);
		Append(~stabs, StabilizerSubalgebra(rand, g, weyl));
		Append(~dims, Dimension(stabs[i]));
	end for;
  
    loc := Argmin(dims);
	return stabs[loc]; // return a stabilizer of minimum dimension
end function;

function genStabDim(g, weyl, irred); // provided for backwards compatibility, now a wrapper for genStab
	return Dimension(genStab(g, weyl, irred));
end function;

/////////////////////////////////////////////////////////////////
//
// Given a Lie algebra g, and an element x,
// return the subalgebra z_g(x) 
//
/////////////////////////////////////////////////////////////////
function LieCentralizerOfElement(g, x);
	ker := Kernel(VerticalJoin([bas*x : bas in Basis(g)]));
    return SubspaceToSubalgebra(g, ker);
end function;

/////////////////////////////////////////////////////////////////
//
// Given a Lie algebra g, and a subalgebra h,
// return the subalgebra z_g(h) 
//
/////////////////////////////////////////////////////////////////
function LieCentralizer(g, h);
	centralizer := g; // start with the whole algebra
	for x in Basis(h) do
		centralizer := centralizer meet LieCentralizerOfElement(g, x);
	end for;

	return centralizer;
end function;

/////////////////////////////////////////////////////////////////
//
// Given a vector space V and a Lie algebra g acting on it via rho,
// find the subspace of V annihilated by all of g
//
/////////////////////////////////////////////////////////////////
function KilledSubspace(g, rho, V);
	subspace := V;
	for x in Basis(g) do
		subspace := subspace meet Kernel(rho(x));
	end for;
	
	return subspace;
end function;

/////////////////////////////////////////////////////////////////
//
// make an irrep with a given highest weight
//
// arguments are
//		g = Lie algebra
//		high_wt = highest weight
//		edim_rep = expected dimension of the irrep
//
// CAUTION: note that Magma numbers the roots of the root system as in Bourbaki, whereas Garibaldi-Guralnick imitates Lubeck's paper
//
/////////////////////////////////////////////////////////////////

function makeIrrep(g, high_wt, edim_rep);
	weyl := HighestWeightRepresentation(g, high_wt); // the Weyl module 
	V := VectorSpace(BaseRing(g), Integers()!Sqrt(Dimension(Codomain(weyl))));

	if edim_rep eq Dimension(V) then // are we told that the Weyl module is irreducible?
		// note that this step is intended to save time when we already know the answer for math reasons
		irred := V;  
	else  // we are told the irrep is a proper submodule, better calculate it
		v := Basis(V)[1]; // highest weight vector
		irred := subGen(V,v, g, weyl); // note that V*weyl(L) is the standard module 
		assert Dimension(irred) eq edim_rep;  // the submodule irred has the right dimension so it is the irrep
	end if;

	return weyl, irred;
end function;

/////////////////////////////////////////////////////////////////
//
// take a morphism rho with image in GL(vspace)
// return a sum of n copies of the representation
//
/////////////////////////////////////////////////////////////////
function SumRep(rho, vspace, n);
	function rho_n(x);
		return DiagonalJoin([rho(x) : i in [1..n]]);
	end function;

	vspace_n := DirectSum([vspace : i in [1..n]]);

	return rho_n, vspace_n;
end function;

// is the element x in the restricted Lie algebra L?
// need to pass a larger algebra "big" containing L if it is not obvious to Magma that L is restricted
function IsSemisimpleElt(L, x : big := L);
	isr, pmap := IsRestricted(big);  // function is only implemented when L is restricted

	assert isr;
	assert x in L;

	vects := [];
	incr := x;
	for i in [1..Dimension(L)] do
		incr := pmap(incr);
		assert incr in L;
		Append(~vects, incr);
	end for;

	vspace := sub<L | vects>; // this is the subalgebra generated by powers of x
	return x in vspace;   // x is semisimple iff it is in the subalgebra
end function;

// Is the Lie algebra L toral?
function IsToralSubalgebra(L : big := L);
	// if it's toral, it's commutative
	if not(IsCommutative(L)) then
		return false;
	end if;

	// if it's toral, every basis consists of semisimple elements
	b := Basis(L);
	for x in b do
		if not(IsSemisimpleElt(L,x : big := big)) then
			return false;
		end if;
	end for;

	return true;
end function;

/////////////////////////////////////////////////////////////////
//
// print a line of text in a box, for breaking output up into sections
//
/////////////////////////////////////////////////////////////////
procedure section(headline);
	len := Max(#headline + 2, 70);
	header := "+" cat "-"^len cat "+";

	if #headline lt 68 then
		headline cat:= " "^(68-#headline);
	end if;

	print header;
	printf "| " cat headline cat " |\n";
	print header;
	printf "\n";
end procedure;




/////////////////////////////////////////////////////////////////
//
// report the version of Magma being used
//
/////////////////////////////////////////////////////////////////
procedure PrintVersion();
	x,y,z := GetVersion();
	printf "Running Magma V%o.%o-%o\n", x, y, z;
end procedure;

SetColumns(0); // turn off automatic word wrapping of output

PrintVersion(); // print the version of Magma that is running
